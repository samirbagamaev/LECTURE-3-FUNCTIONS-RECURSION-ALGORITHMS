# АЛГОРИТМЫ

# Алгоритмом называется набор инструкций для выполнения
# некоторой задачи. В принципе, любой фрагмент
# программного кода можно назвать алгоритмом, но мы с
# Вами рассмотрим 2 самых интересных алгоритмы
# сортировок:

# ● Быстрая сортировка
# ● Сортировка слиянием

#...................................................................................

# БЫСТРАЯ СОРТИРОВКА

# “Программирование это разбиение чего-то большого и невозможного на что-то маленькое и
# вполне реальное”
# Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”. Сначала
# рассмотрим пример, затем напишем программный код

# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
# Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
# 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
# и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
# который отгадывает.

# Итак начнем:

# Иван загадал число 77.
# Петр: Число больше 50? Иван: Да.
# Петр: Число больше 75? Иван: Да.
# Петр: Число больше 87? Иван: Нет.
# Петр: Число больше 81? Иван: Нет.
# Петр: Число больше 78? Иван: Нет.
# Петр: Число больше 76? Иван: Да

# Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена. На самом деле мы
# сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии
# “разделяй и властвуй”. Давайте перейдем к обсуждению программного кода быстрой
# сортировки.


# def quicksort(array):
 
#  if len(array) < 2:
#   return array
#  else:
#   pivot = array[0]
#  less = [i for i in array[1:] if i <= pivot]
#  greater = [i for i in array[1:] if i > pivot]
#  return quicksort(less) + [pivot] + quicksort(greater)

# print(quicksort([10, 5, 2, 3])) #ОТВЕТ: [2, 3, 5, 10]



# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])

# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
# добавляется список [10]

# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5,
# 10]


#...................................................................................


#СОРТИРОВКА СЛИЯНИЕМ

def merge_sort(nums):
    if len(nums) > 1 :
        mid = len(nums) // 2
        left = nums[:mid]
        right = nums[mid:]
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            k += 1

        while i < len(left):
            nums[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            nums[k] = right[j]
            j += 1
            k += 1    

list1 = [ 1, 5, 6, 9, 8, 7, 2, 1, 55, 2, 4]
merge_sort(list1) 
print(list1)

#ОТВЕТ: [1, 1, 2, 2, 4, 5, 6, 7, 8, 9, 55]
               